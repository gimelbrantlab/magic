#!/usr/bin/env Rscript

# Runs classifiers generated by generate.R on data processed by process.R

# Copyright (C) 2017 Dana-Farber Cancer Institute Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Questions, comments and concerns can be directed to
#   Alexander Gimelbrant: alexander_gimelbrant@dfci.harvard.edu
#   Sebastien Vigneau: Sebastien_Vigneau@dfci.harvard.edu
#   Svetlana Vinogradova: Svetlana_Vinogradova@dfci.harvard.edu
#   Henry Ward: henry.neil.ward@gmail.com
#   Sachit Saksena: sachitdsaksena@utexas.edu

######
# MAIN FUNCTIONS
######


# Loads all prediction sets in a given folder into a single dataframe
join_prediction_sets <- function(df, predictions_folder) {
  
  # List of prediction sets to build up
  df$id <- 1:nrow(df)
  sets <- df
  
  # Loops through all files and reads in all ending with "_predictions.tsv"
  sets_files <- list.files(predictions_folder, pattern = "*_predictions.tsv", recursive = FALSE)
  for (file in sets_files) {
    p_set <- read.csv(file.path(predictions_folder, file), sep = "\t")
    # Adds id col to set
    p_set$id <- 1:nrow(p_set)
    
    # Renames cols with model name prepended
    model_name <- strsplit(file, "_")[[1]][1]
    names_to_change <- names(p_set)[names(p_set) != "id"]
    names(p_set)[names(p_set) != "id"] <-
      paste(model_name, names_to_change, sep = "_")
    
    # Joins sets
    sets <- suppressWarnings(full_join(sets, p_set, by = "id"))
  }
  
  # Removes id column from output
  sets <- sets[,names(p_set) != "id"]
  
  # Explicitly returns list of testing sets
  return(sets)
}

# Loads all models in a given folder into a dict, except
# for those in the list of excluded models
get_models <- function(input_folder, excluded_models) {
  
  # List of models to build up
  models <- list()
  
  # Loops through all files and reads in all ending with "_model.rds"
  model_files <- list.files(input_folder, pattern = "*_model.rds", recursive = FALSE)
  for (file in model_files) {
    model_name <- strsplit(file, "_model.rds")[[1]][1]
    if (!(model_name %in% excluded_models)) {
      model <- readRDS(file.path(input_folder, file))
      models[[model_name]] = model
    }
  }
  
  # Explicitly returns list of models
  return(models)
}

# Generates predictions for a single model and logs those to file
ml_predict_inner <- function(model_name, model, df,
                             output_folder, positive_class, filter_file, filter_length,
                             filter_expression, filter_species) {
  # Check that model has the same features as joined_scores_percentile
  features_model <- model$coefnames
  features_df <- colnames(df)
  for (f in features_model) {
    if (!(f %in% features_df)) { stop(paste0("Features in the model and joined_scores_percentile are not consistent, please train a new model with your joined_scores_percentile.", 
                                             "Model's features: ", paste(features_model, collapse=", "))) }
  }
  # Generates predictions, appends to df and writes to file
  predictions <-  predict(model, df, positive = positive_class)
  df$predictions <- predictions
  predictions_file <- file.path(output_folder,
                                paste(model_name, "predictions.tsv", sep = "_"))
  df <- filter_genes(df, filter_file, filter_length, filter_expression, filter_species)
  write.table(df, predictions_file, sep = "\t", row.names = FALSE,
              quote = FALSE)
}

# Generates predictions on new data
ml_predict <- function(df, models_folder, output_folder,
                       excluded_models, positive_class, filter_file, filter_length, filter_expression, filter_species) {
  
  # Loads models into a dict with model names as keys
  models <- get_models(models_folder, excluded_models)
  
  # Generates predictions on df for all models
  for (model_name in names(models)) {
    ml_predict_inner(model_name, models[[model_name]], df,
                     output_folder, positive_class, filter_file, filter_length, filter_expression, filter_species)
  }
  
  # Joins all files with appended predictions together
  df <- join_prediction_sets(df, output_folder)
  return(df)
}

# Filters genes by expression and/or length
filter_genes <- function(df, filter_file, filter_length, filter_expression, filter_species) {
  reference_folder <- file.path(dirname(current_folder), "reference")
  if (filter_length>0) {
    # Filtering by length
    print("Filtering by length")
    if (filter_species=="human") {
      df_length <- read.delim(file.path(reference_folder, "hg19_length.txt"))
      df <- merge(df, df_length, by.x="name", by.y="gene")
      df <- df %>% dplyr::filter(length >= filter_length)
    }
    else if (filter_species=="mouse") {
      df_length <- read.delim(file.path(reference_folder, "mm10_length.txt"))
      df <- merge(df, df_length, by.x="name", by.y="gene")
      df <- df %>% dplyr::filter(length >= filter_length)
    }
    else {
      print("Unknown species, filtering disabled")
    }
  }
  if (filter_expression) {
    # Filtering by expression
    print("Filtering by expression")
    f_file <- read.csv(filter_file, sep = "\t", header = TRUE)
    if (dim(f_file)[2]>2) { stop("Please provide expression file with only two columns: name and expression value") }
    colnames(f_file) <- c("name", "expression")
    df <- merge(df, f_file, by.x="name", by.y="name")
    df <- df %>%
      arrange(desc(expression)) %>%
      head(round(nrow(df)/2)+1)
  }
  return(df)
}

# Analyzes given dataset
analyze_main <- function(current_folder, input_file, models_folder,
                         output_folder, excluded_models, positive_class,
                         filter_file, filter_length, filter_expression, filter_species, lib) {
  
  # Loads required libraries
  load_analyze_libraries(lib)
  
  # Reads input file into df and removes NA values
  df <- read.csv(input_file, sep = "\t")
  df <- df[complete.cases(df),]
  
  # Reads excluded models string into a list
  excluded_models <- as.list(strsplit(excluded_models, ",")[[1]])
  
  # Generates predictions and appends them to df
  df <- ml_predict(df, models_folder, output_folder,
                   excluded_models, positive_class, filter_file, filter_length, 
                   filter_expression, filter_species)
  
  # Writes predictions to file
  #write.table(df, file.path(output_folder, "all_predictions.tsv"), sep = "\t",
  #            row.names = FALSE, quote = FALSE)
  
  cat("Analysis complete.\n")
}

######
# COMMAND LINE INTERFACE
######


# Suppressingfire's SO solution to get executing script.
# Found at http://stackoverflow.com/questions/30468412/dplyr-join-warning-joining-factors-with-different-levels
args <- commandArgs()
current_folder <- dirname(sub("--file=", "", args[grep("--file=", args)]))

# Gets path to models folder and loads utility functions
models_folder <- file.path(current_folder, "..", "models")
source(file.path(current_folder, "utils.R"))

# Gets custom install directory if used in install.R
lib <- get_install_dir(paste0(getwd(), "/../../"))

# Loads optparse
load_initial_libraries(lib)

# Builds option list using optparse
options = list(
  make_option(c("-i", "--input_file"), type="character", default=NULL,
              help="file output from process.R, see readme for description"),
  make_option(c("-m", "--models_folder"), type="character", default=models_folder,
              help="contains models output from generate.R"),
  make_option(c("-o", "--output_folder"), type="character", default="analyze_output",
              help="output folder [default= %default]"),
  make_option(c("-ex", "--excluded_models"), type="character", default="",
              help="list of models to exclude from folder, separated by commas"),
  make_option(c("-p", "--positive_class"), type="character", default="MAE",
              help="name of target feature's positive class [default=%default]"),
  make_option(c("-r", "--expr_filter"), action="store_true", default=FALSE,
              help="filter by expression [default= %default]"),
  make_option(c("-f", "--filter"), type="character", default=NULL,
              help="file with gene expression, see readme for file format"),
  make_option(c("-l", "--f_length"), type="integer", default=2500,
              help="gene length threshold [default= %default]"),
  make_option(c("-s", "--species"), type="character", default="human",
              help="human or mouse (used for length filtering) [default= %default]"),
  make_option(c("-q", "--quiet"), action="store_true", default=FALSE,
              help="disables console output [default= %default]")
)

# Gets options and checks arguments
opt <- parse_args(OptionParser(option_list = options))
if (!file.exists(opt$input_file)) { stop("input file does not exist") }
if (!is.null(opt$filter))
  if(!file.exists(opt$filter)) { stop("file with expression does not exist") }
if (opt$expr_filter) {
  if (!is.null(opt$filter)) {
    if(!file.exists(opt$filter)) { 
      stop("file with expression does not exist") 
    }
  }
  else { 
    stop("please provide a file with expression") 
  }
}
if ((opt$species != "human") & (opt$species != "mouse")) { stop("please select a valid species") }
if (!dir.exists(opt$models_folder)) { stop("models folder does not exist") }
if (!dir.exists(opt$output_folder)) { 
  dir.create(opt$output_folder, recursive = TRUE) 
} else {
  do.call(file.remove, list(list.files(opt$output_folder, full.names = TRUE)))
}

# Extracts variables from args
input_file <- opt$input_file
models_folder <- opt$models_folder
output_folder <- opt$output_folder
excluded_models <- opt$excluded_models
positive_class <- opt$positive_class
quiet <- opt$quiet
filter_file <- opt$filter
filter_length <- opt$f_length
filter_expression <- opt$expr_filter
filter_species <- opt$species

# Calls main function, disabling output if running in quiet mode
if (!quiet) {
  invisible(analyze_main(current_folder, input_file, models_folder,
                         output_folder, excluded_models, positive_class,
                         filter_file, filter_length, 
                         filter_expression, filter_species, lib))
} else {
  analyze_main(current_folder, input_file, models_folder,
               output_folder, excluded_models, positive_class, filter_file, filter_length, 
               filter_expression, filter_species, lib)
}
